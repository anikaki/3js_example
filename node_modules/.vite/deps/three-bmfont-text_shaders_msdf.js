import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/three-bmfont-text/shaders/msdf.js
var require_msdf = __commonJS({
  "node_modules/three-bmfont-text/shaders/msdf.js"(exports, module) {
    var assign = require_object_assign();
    module.exports = function createMSDFShader(opt) {
      opt = opt || {};
      var opacity = typeof opt.opacity === "number" ? opt.opacity : 1;
      var alphaTest = typeof opt.alphaTest === "number" ? opt.alphaTest : 1e-4;
      var precision = opt.precision || "highp";
      var color = opt.color;
      var map = opt.map;
      var negate = typeof opt.negate === "boolean" ? opt.negate : true;
      delete opt.map;
      delete opt.color;
      delete opt.precision;
      delete opt.opacity;
      delete opt.negate;
      return assign({
        uniforms: {
          opacity: { type: "f", value: opacity },
          map: { type: "t", value: map || new THREE.Texture() },
          color: { type: "c", value: new THREE.Color(color) }
        },
        vertexShader: [
          "attribute vec2 uv;",
          "attribute vec4 position;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 modelViewMatrix;",
          "varying vec2 vUv;",
          "void main() {",
          "vUv = uv;",
          "gl_Position = projectionMatrix * modelViewMatrix * position;",
          "}"
        ].join("\n"),
        fragmentShader: [
          "#ifdef GL_OES_standard_derivatives",
          "#extension GL_OES_standard_derivatives : enable",
          "#endif",
          "precision " + precision + " float;",
          "uniform float opacity;",
          "uniform vec3 color;",
          "uniform sampler2D map;",
          "varying vec2 vUv;",
          "float median(float r, float g, float b) {",
          "  return max(min(r, g), min(max(r, g), b));",
          "}",
          "void main() {",
          "  vec3 sample = " + (negate ? "1.0 - " : "") + "texture2D(map, vUv).rgb;",
          "  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;",
          "  float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);",
          "  gl_FragColor = vec4(color.xyz, alpha * opacity);",
          alphaTest === 0 ? "" : "  if (gl_FragColor.a < " + alphaTest + ") discard;",
          "}"
        ].join("\n")
      }, opt);
    };
  }
});
export default require_msdf();
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=three-bmfont-text_shaders_msdf.js.map
